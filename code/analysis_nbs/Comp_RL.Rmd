---
title: "RL models comparison"
output:
github_document:
toc: yes
toc_float: yes
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
fig_path = '/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_Analyses/output/figures/'

from_gh=FALSE
source('/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_Analyses/code/helper_functions/ggplot_colors.R')
source('/Users/zeynepenkavi/Dropbox/PoldrackLab/SRO_Retest_Analyses/code/helper_functions/transform_remove_skew.R')
source('/Users/zeynepenkavi/Dropbox/PoldrackLab/SRO_Retest_Analyses/code/helper_functions/sem.R')
source('/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_Analyses/code/workspace_scripts/rl_fits_data.R')
```

```{r eval=FALSE}
# Save plot of neglogprob distributions for all subject for each model
for(f in fits){
  data = read.csv(paste0(input_dir, f))
  data = process_fits(data)
  p = data %>% 
  ggplot(aes(neglogprob))+
  geom_histogram()+
  facet_wrap(~sub_id, scales='free')
  p_name = gsub('.csv','',f)
  p_name = gsub('LearningParams','Neglogs',p_name)
  ggsave(paste0(p_name, '.jpeg'), plot=p, device = 'jpeg', path = paste0(fig_path, 'neglogs'), width = 30, height = 30, units = "in", limitsize = FALSE)
}
```


The behavior in the machine game task lends itself to prediction error modeling as frequently done in the literature. 

In this approach the probability of playing a machine is modeled as: 

$p(k_{t} = 1) = \frac{e^{\beta*(EV_t)}}{1+e^{\beta*(EV_t)}}$  

where the $EV_t$ is updated after observing the reward ($r$) in each trial at a learning rate ($\alpha$) by a prediction error that can be distorted non-linearly by an exponent ($\gamma$)  

${EV_{t+1}} = {EV_t} + \alpha * (r - {EV_t})^\gamma$  

The parameters of the model are:  

- $\alpha$ - learning rate. Higher values mean faster learning. Can be allowed to vary for gains and losses as $\alpha_{pos}$ and $\alpha_{neg}$   
- $\gamma$ - value concavity exponent. Higher values mean less distortion of prediction error. Can be omitted (i.e. fixed to 1) and allowed to vary for gains and losses as $exp_{pos}$ and $exp_{neg}$  
- $\beta$ - inverse temperature. Higher values mean subjects are choosing based on expected value, lower means the choice is driven less by EV and more by random guessing (for $\beta = 0$ all choices are equally likely).  

To determine the best model we ran models where these parameters were allowed to vary for gains and losses and were either estimated for each subject. 

Each model was fit 50 times for each subject minimizing negative log probability. Fit quality is evaluated using BIC for each fit. 

## Model comparison

Which is the best model?

Plotting each model's prediction accuracy when predicting the quarter of left out data for each subject after fitting the model on the remaining three quarters of data.

```{r}
mean_pred_df = ave_sub_preds %>%
  group_by(model) %>%
  summarise(ave_pred_prop = mean(cor_pred_prop),
            sem_pred_prop = sem(cor_pred_prop)) %>%
  left_join(num_pars_df %>%
              mutate(model = gsub("LearningParams_", "", model)) %>%
              select(-pars), 
            by="model") %>%
  mutate(x_axis = factor(x_axis, levels=unique(x_axis[order(ave_pred_prop, x_axis)]), ordered=TRUE),
         pred_order = as.numeric(x_axis))
```

```{r}
mean_pred_df %>%
  ggplot(aes(x_axis, ave_pred_prop))+
  geom_point()+
  geom_errorbar(aes(ymin = ave_pred_prop-sem_pred_prop, ymax = ave_pred_prop+sem_pred_prop))+
  xlab("")+
  ylab("Mean prediction accuracy")+
  scale_x_discrete(labels = function(x) str_wrap(x, width=5))

ggsave("RL_models_comp_pred.jpeg", device = "jpeg", path = fig_path, width = 7, height = 5, units = "in", dpi = 450)
```

Do models differ from each other based on prediction accuracy? Only the worst two.

```{r}
tmp = with(ave_sub_preds, pairwise.t.test(cor_pred_prop, model), p.adj="fdr")
tmp = data.frame(tmp$p.value)
tmp = tmp %>%
  mutate(model1 = row.names(tmp)) %>%
  gather(model2, p_value, -model1) %>%
  mutate(model2 = gsub('\\.', '-', model2)) %>%
  filter(p_value <0.05) %>%
  arrange(model1)

tmp
```

Plotting the best model/model with lowest average BIC for the bounded estimations.

```{r message = FALSE, warning = FALSE}
mean_bic_df = best_sub_pars %>%
  select(x_axis, BIC) %>%
  group_by(x_axis) %>%
  summarise(mean_bic = mean(BIC), 
            sem_bic = sem(BIC)) %>%
  mutate(x_axis = factor(x_axis, levels=unique(x_axis[order(-mean_bic, x_axis)]), ordered=TRUE), 
         bic_order = as.numeric(x_axis)) 
```


```{r}
mean_pred_df %>%
  left_join(mean_bic_df %>% select(x_axis, bic_order), by="x_axis") %>%
  mutate(rank_diff = abs(pred_order - bic_order)) %>%
  filter(rank_diff>3)
```

```{r}
mean_bic_df %>%
  ggplot(aes(factor(x_axis), mean_bic))+
  geom_point()+
  geom_errorbar(aes(ymin=mean_bic-sem_bic, ymax=mean_bic+sem_bic))+
  theme(legend.position = "none",
        panel.grid=element_blank())+
  xlab("")+
  ylab("Mean BIC across subjects")+
  scale_x_discrete(labels = function(x) str_wrap(x, width=5))

ggsave("RL_models_comp_BIC.jpeg", device = "jpeg", path = fig_path, width = 7, height = 5, units = "in", dpi = 450)
```

Do average BIC's for each model differ from each other? No.

```{r}
tmp = with(best_sub_pars, pairwise.t.test(BIC, model))
tmp = data.frame(tmp$p.value)
tmp = tmp %>%
  mutate(model1 = row.names(tmp)) %>%
  gather(model2, p_value, -model1) %>%
  mutate(model2 = gsub('\\.', '-', model2)) %>%
  filter(p_value !=1) %>%
  arrange(model1)

tmp
```

So far we only looked at average BIC's. To confirm that the overall tendency for smaller BICs in the best model is meaningful we compare the fit indices for the best two models for each subject.   

To do this we calculate a Bayes Factors as listed in [Wagenmaakers (2007)](https://link-springer-com.stanford.idm.oclc.org/content/pdf/10.3758%2FBF03194105.pdf)

$BF_{01} = exp(\frac{BIC_1 - BIC_0}{2})$

the smaller this is the more evidence for H1 (the 4 parameter model with a single learning rate and two exponents). Here we take the simpler model to be H1 and the more complicated one as H0 (the 5 parameter model with two learning rates and two exponents). $BF_{01}$ < 3 suggests weak evidence for H0 and therefore a preference for H1.  

The percentage of participants with weak evidence for H0 and for whom therefore the simpler model H1 would be preferred is:

```{r}
tmp = best_sub_pars %>%
  filter(model %in% c('Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_', 'Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_')) %>%
  select(sub_id, BIC, model) %>%
  group_by(sub_id) %>%
  mutate(model = gsub("-", "_", model)) %>%
  spread(model, BIC) %>%
  mutate(BF01 = exp((Fit_alpha_beta_exp_neg_exp_pos_Fix_lossave_ - Fit_alpha_neg_alpha_pos_beta_exp_Fix_lossave_)/2),
         simpler_model_better = ifelse(BF01<3,1,0)) %>%
  drop_na(simpler_model_better)

sum(tmp$simpler_model_better)/nrow(tmp)*100
```

The 'best' model based on average BIC using bounded estimation is the best for 76.6% of the subjects.

### Age differences in fit

Do models differ in fit by age group?   

Only for the model with two learning rates the fits are more variable for kids than for other groups.

```{r}
mean_bic_df  %>%
  ggplot(aes(factor(x_axis),mean_bic, color=age_group))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_bic-sem_bic, ymax = mean_bic+sem_bic))+
  xlab("")+
  ylab("Mean BIC across subjects")+
  theme(axis.text.x = element_blank(),
        legend.title = element_blank(),
        panel.grid = element_blank())

ggsave("RL_models_comp_age.jpeg", device = "jpeg", path = fig_path, width = 7, height = 5, units = "in", dpi = 450)
```

### Comparison of BIC distributions

Bayes Factor check above suggested that for a majority of the subjects the 4 parameter model with the lowest BIC is supported more than the next best model. But are do these BIC distributions even have different means? The simplest model has a higher mean than the rest but the others do not differ from each other.

```{r}
summary(lm(BIC ~ model, best_sub_pars))
```

### Differing conclusions

Do the models tell the same story when checking for age differences across parameter?

Or a similar story that doesn't make sense with the behavior?

Which parameters show age differences in which models?

```{r}
models = unique(best_sub_pars$model)[unique(best_sub_pars$model) %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_")==FALSE]

age_diff_df = data.frame(model = NA, par = NA, teen=NA, adult=NA)

for(i in 1:length(models)){
  cur_data = best_sub_pars %>% filter(model == models[i])
  cur_data = cur_data %>% select(age_group, contains("xopt"))
  cur_data = cur_data[,colSums(is.na(cur_data))<nrow(cur_data)]
  cur_data = transform_remove_skew(cur_data)
  names(cur_data)[1] = "age_group"
  pars = names(cur_data)[!names(cur_data) %in% c("age_group")]
  
    for(j in 1:length(pars)){
      p_vals = summary(lm(cur_data[,pars[j]] ~ cur_data[,"age_group"]))$coefficients[c(2,3),4]
      age_diff_df[nrow(age_diff_df) + 1,] = list(models[i],pars[j], p_vals[1], p_vals[2])
    }
}
age_diff_df = age_diff_df[-1,]
# age_diff_df %>%
#   arrange(adult, teen)
age_diff_df %>%
  mutate(adult_adjust = p.adjust(adult), method="fdr")%>%
  filter(adult<0.05)
```

```{r}
tmp = num_pars_df %>%
  mutate(model = gsub("LearningParams_", "", model)) %>%
  select(model, x_axis)

fct_brdr_clrs = age_diff_df %>%
  #excluding models with lambda
  filter(grepl("lossave_Fix", model)==FALSE) %>%
  mutate(adult_adjust = p.adjust(adult), method="fdr")%>%
  select(model, par, adult, adult_adjust) %>%
  mutate(fct_brdr = ifelse(adult<0.5, "purple", NA),
         fct_brdr = ifelse(adult_adjust<0.5, "red", fct_brdr)) %>%
  left_join(tmp, by="model") %>%
  select(par, x_axis, fct_brdr)

#fct_brdr_clrs %>%
#  filter(is.na(fct_brdr)==FALSE)
```

```{r message = FALSE, warning=FALSE}
best_sub_pars %>%
  #Excluding models that do not separate between gain and loss learning
  filter(model %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_") == FALSE) %>%
  select(contains("xopt"), "sub_id", "x_axis", "age_group") %>%
  gather(key, value, -age_group, -sub_id, -x_axis) %>%
  mutate(par=key,
         key = ifelse(key == "xopt_alpha", "\u03b1", ifelse(key == "xopt_beta", "\u03b2", ifelse(key == "xopt_exp", "\u03b3", ifelse(key == "xopt_alpha_pos", "\u03b1_gain", ifelse(key == "xopt_alpha_neg", "\u03b1_loss",ifelse(key == "xopt_exp_pos", "\u03b3_gain", ifelse(key == "xopt_exp_neg", "\u03b3_loss", ifelse(key == "xopt_lossave", "\u03bb", NA)))))))))%>%
  group_by(age_group, x_axis, key, par) %>%
  summarise(mean_val = mean(value,na.rm=T),
            sem_val = sem(value)) %>%
  left_join(fct_brdr_clrs, by=c("par", "x_axis")) %>%
  filter(grepl("\u03bb",x_axis) == FALSE) %>%
  filter(grepl("\u03bb",key) == FALSE) %>%
    ggplot(aes(age_group, mean_val))+
    geom_bar(aes(fill=age_group, color=fct_brdr), stat="identity",size=1.25)+
    geom_errorbar(aes(ymin=mean_val-sem_val, ymax=mean_val+sem_val), width=0)+
  facet_grid(key~x_axis, scales='free')+
  ylab("")+
  xlab("")+
  theme(panel.grid = element_blank(),
        legend.position = "none")+
  scale_color_manual(values=c("purple", "red", NA))

ggsave("RL_par_diffs_nolamda.jpeg", device = "jpeg", path = fig_path, width = 10, height = 5.6, units = "in", dpi = 450)
```

## Cor btw PEs

```{r}
input_path = '/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_Analyses/input/'

preds = list.files(path=paste0(input_path, "rl_preds/"), pattern = "All")

all_mods_preds = data.frame()
all_mods_pes = data.frame()

for(f in preds){
  data = read.csv(paste0(input_path, "rl_preds/", f))
  all_mods_preds = rbind.all.columns(all_mods_preds,data.frame(data))
  data = data %>% select(PE, sub_id, X, model)
  names(data)[which(names(data)=="PE")] = paste0("PE_",unique(data$model))
  data = data %>% select(-model)
  if(nrow(all_mods_pes)==0){
    all_mods_pes = data
  }
  else{
    all_mods_pes = all_mods_pes %>%
      left_join(data, by=c("sub_id", "X"))
  }
}

all_mods_pes = all_mods_pes %>%
  select(X, sub_id, everything())
```

```{r}
mods = grep("PE", names(all_mods_pes), value=T)
cor_df = data.frame(sub_id = NA, var1 = NA, var2=NA, cor_val=NA)
for(i in 1:(length(mods) - 1) ){
  rem_mods = mods[-c(1:i)]
  
  for(j in 1:length(rem_mods)){
    cur_data = all_mods_pes %>% select(sub_id, mods[i], rem_mods[j])
    
    cur_cor_df = cur_data %>% 
      group_by(sub_id) %>% 
      do(data.frame(Cor=t(cor(.[,2], .[,3], use="pairwise")))) %>% 
      mutate(var1 = mods[i],
             var2 = rem_mods[j]) %>%
      select(sub_id, var1, var2, everything())
    
    names(cur_cor_df) = c("sub_id", "var1", "var2", "cor_val")
    
    cor_df = rbind(cor_df, data.frame(cur_cor_df))
    
  }
} 

cor_df = cor_df[-1,]
```

Distributuons of correlations between PE's generated by different models for each subject (sorted by the median correlation for model pair)

```{r warning=FALSE, message=FALSE}
tmp = num_pars_df %>%
  mutate(model = gsub("LearningParams_", "", model)) %>%
  select(model, x_axis)

cor_df %>%
  mutate(var1 = gsub("PE_Preds_", "", var1),
         var2 = gsub("PE_Preds_", "", var2)) %>%
  #Exclude models that don't distinguish gain and loss learning at all
  filter(var1 %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_") == FALSE) %>%
  filter(var2 %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_") == FALSE) %>%
  #Exclude models with lambda
  filter(grepl("lossave_Fix", var1) == FALSE) %>%
  filter(grepl("lossave_Fix", var2) == FALSE) %>%
  left_join(tmp, by=c("var1"="model")) %>%
  left_join(tmp, by=c("var2"="model")) %>%
  mutate(cor_type = paste0(x_axis.x, " VS. ", x_axis.y)) %>%
  group_by(cor_type) %>%
  mutate(med_cor_val = median(cor_val, na.rm=T)) %>%
  ggplot(aes(reorder(cor_type,med_cor_val), cor_val ))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle=90),
        legend.position = "none")+
  ylab("Correlation between PEs")+
  xlab("")+
  coord_flip()

ggsave("PE_corrs.jpeg", device = "jpeg", path = fig_path, width = 7, height = 5, units = "in", dpi = 450)
```

Create average PE's for all subjects using the three models that have highly correlated PEs. These three models are also the best fitting models. The PEs created in this way will be used for imaging analyses.

```{r}
get_ave_pe = function(sub_data){
  sub_data = sub_data %>%
  select(X, sub_id, "PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","PE_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_")
  
  drop_cols = c()
  
  for(col in c("PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","PE_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_")){
    if(sum(is.na(sub_data[,col]))==180){
      drop_cols = c(drop_cols, col)
    }
  }
  
  rem_cols = setdiff(c("PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","PE_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","PE_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_"), drop_cols)
  
  sub_data = sub_data %>%
    mutate(ave_PE = rowSums(select(., rem_cols))/length(rem_cols)) %>%
    select(X, sub_id, ave_PE) %>%
  filter(is.na(ave_PE) == FALSE)
  
  return(sub_data)
}

ave_pes = all_mods_pes %>%
  group_by(sub_id) %>%
  do(get_ave_pe(.))

# write.csv(ave_pes, '/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_ServerScripts/nistats/level_1/ave_pes.csv', row.names=FALSE)
```

## Cor btw EVs

```{r}
all_mods_evs = data.frame()

for(f in preds){
  data = read.csv(paste0(input_path, "rl_preds/", f))
  data = data %>% select(EV, sub_id, X, model)
  names(data)[which(names(data)=="EV")] = paste0("EV_",unique(data$model))
  data = data %>% select(-model)
  if(nrow(all_mods_evs)==0){
    all_mods_evs = data
  }
  else{
    all_mods_evs = all_mods_evs %>%
      left_join(data, by=c("sub_id", "X"))
  }
}

all_mods_evs = all_mods_evs %>%
  select(X, sub_id, everything())
```

```{r}
mods = grep("EV", names(all_mods_evs), value=T)
cor_df = data.frame(sub_id = NA, var1 = NA, var2=NA, cor_val=NA)
for(i in 1:(length(mods) - 1) ){
  rem_mods = mods[-c(1:i)]
  
  for(j in 1:length(rem_mods)){
    cur_data = all_mods_evs %>% select(sub_id, mods[i], rem_mods[j])
    
    cur_cor_df = cur_data %>% 
      group_by(sub_id) %>% 
      do(data.frame(Cor=t(cor(.[,2], .[,3], use="pairwise")))) %>% 
      mutate(var1 = mods[i],
             var2 = rem_mods[j]) %>%
      select(sub_id, var1, var2, everything())
    
    names(cur_cor_df) = c("sub_id", "var1", "var2", "cor_val")
    
    cor_df = rbind(cor_df, data.frame(cur_cor_df))
    
  }
} 

cor_df = cor_df[-1,]
```

```{r}
cor_df %>%
  mutate(var1 = gsub("EV_Preds_", "", var1),
         var2 = gsub("EV_Preds_", "", var2)) %>%
  #Exclude models that don't distinguish gain and loss learning at all
  filter(var1 %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_") == FALSE) %>%
  filter(var2 %in% c("Fit_alpha-beta-exp_Fix_lossave_", "Fit_alpha-beta_Fix_exp-lossave_") == FALSE) %>%
  #Exclude models with lambda
  filter(grepl("lossave_Fix", var1) == FALSE) %>%
  filter(grepl("lossave_Fix", var2) == FALSE) %>%
  left_join(tmp, by=c("var1"="model")) %>%
  left_join(tmp, by=c("var2"="model")) %>%
  mutate(cor_type = paste0(x_axis.x, " VS. ", x_axis.y)) %>%
  group_by(cor_type) %>%
  mutate(med_cor_val = median(cor_val, na.rm=T)) %>%
  ggplot(aes(reorder(cor_type,med_cor_val), cor_val ))+
  geom_boxplot()+
  theme(axis.text.x = element_text(angle=90),
        legend.position = "none")+
  ylab("Correlation between EVs")+
  xlab("")+
  coord_flip()

```

```{r}
get_ave_ev = function(sub_data){
  sub_data = sub_data %>%
  select(X, sub_id, "EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","EV_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_")
  
  drop_cols = c()
  
  for(col in c("EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","EV_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_")){
    if(sum(is.na(sub_data[,col]))==180){
      drop_cols = c(drop_cols, col)
    }
  }
  
  rem_cols = setdiff(c("EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_Fix_lossave_","EV_Preds_Fit_alpha_neg-alpha_pos-beta-exp_neg-exp_pos_Fix_lossave_","EV_Preds_Fit_alpha-beta-exp_neg-exp_pos_Fix_lossave_"), drop_cols)
  
  sub_data = sub_data %>%
    mutate(ave_EV = rowSums(select(., rem_cols))/length(rem_cols)) %>%
    select(X, sub_id, ave_EV) %>%
  filter(is.na(ave_EV) == FALSE)
  
  return(sub_data)
}

ave_evs = all_mods_evs %>%
  group_by(sub_id) %>%
  do(get_ave_ev(.))

# write.csv(ave_evs, '/Users/zeynepenkavi/Dropbox/PoldrackLab/DevStudy_ServerScripts/nistats/level_1/ave_evs.csv', row.names=FALSE)
```
